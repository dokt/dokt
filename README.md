# Domain-driven design using Kotlin

[![GitHub license](https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat)](http://www.apache.org/licenses/LICENSE-2.0)
[![Kotlin](https://img.shields.io/badge/kotlin-1.6.10-blue.svg?logo=kotlin)](http://kotlinlang.org)

This framework lets you start your coding from *domain layer* with pure [Common Kotlin](https://kotlinlang.org/docs/multiplatform.html). Test-driven development is also supported via generated unit test stubs.

The Dokt plugin generates *application layer*, which follows *Command and Query Responsibility Segregation (CQRS)* and *Event Sourcing (ES)* patterns. It can't generate *infrastructure layer* :) but you can code it to any platform. 

## Features
- The domain logic depends on only [Common Kotlin](https://kotlinlang.org/docs/multiplatform.html).
- Boilerplate code is generated by Dokt Gradle plugin:
  - Configures project Gradle, plugin and library dependencies
  - Generates application layer code, [Kotest](https://kotest.io/) unit tests and project documentation
- Runtime is fast as possible
  - Generates reflectionless code and slow *kotlin-reflect* is't needed.
  - [Coroutines](https://kotlinlang.org/docs/coroutines-overview.html) are utilized in:
    - Command handlers (transaction locks only single aggregate and there isn't evil **global sequences**).
    - Event handlers (outside aggregate)
  - [Serialization](https://github.com/Kotlin/kotlinx.serialization) code is generated at compile-time.

## The "Hello, World!" tutorial:
1. Apply Dokt plugin in the [build.gradle.kts](examples/hello/build.gradle.kts) file:
  ```kotlin
plugins {
    id("app.dokt") version "0.2.0"
}
  ```
2. Write domain logic in [src/commonMain/kotlin/Hello.kt](examples/hello/src/commonMain/kotlin/Hello.kt) file:
  ```kotlin
import app.dokt.Root
import kotlinx.serialization.Serializable

/** Events that Greeter emits  */
interface Events {
    fun greeted(greeting: String)
}

/** Greeter aggregate root. Identified by UUID (default). */
@Serializable // For unit testing
class Greeter : Root<Events>(), Events {
    val greetings = mutableListOf<String>()

    /** Greet command handler */
    fun greet(who: String) {
        if (who.isBlank()) throw IllegalArgumentException("Missing 'who'!")
        emit.greeted("Hello, $who!")
    }

    /** Greeted event handler */
    override fun greeted(greeting: String) {
        greetings.add(greeting)
    }
}
  ```
3. Run `generateCode` task.
4. Write unit test in [src/commonTest/kotlin/GreeterTest.kt](examples/hello/src/commonTest/kotlin/GreeterTest.kt) file:
  ```kotlin
/** Greeter unit tests */
class GreeterTest : GreeterSpec({ // GreeterSpec is generated in previous step.
    greet { // Command handler is a generated test context
        test("World") { // "World" test case
            greeter // Greeter is arranged with a random UUID.
                .act { greet("World") } // The command act
                .emits(Greeted("Hello, World!")) // Asserts that only the generated Greeted event object is emitted.
        }
    }
})
  ```
5. Run `allTests` and you should pass your test.

Check more [examples](examples/README.md).

## Thanks

Following frameworks have inspired this project a lot:
- [AxonFramework](https://github.com/AxonFramework/AxonFramework) by [Allard Buijze](https://github.com/abuijze) (the best for JVM)
- [EventFlow](https://github.com/eventflow/EventFlow) by [Rasmus Mikkelsen](https://github.com/rasmus) (the best for .Net)
